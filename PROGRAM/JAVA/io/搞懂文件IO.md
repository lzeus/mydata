#搞懂 Java IO-面向流的IO

## 1. 预备知识

### 1.1. 系统调用

遵循POSIX规范的操作系统，将内核提供的各项系统服务包装为系统调用，向C语言提供服务调用入口。

- 这些系统调用以C语言的同名函数申明在unistd.h中。
- 系统调用函数与普通函数在使用上没有区别。
- 每一次系统调用当前进程就会从用户态切换到内核态。

<img style="block-inline" src="https://github.com/lzeus/mydata/raw/master/SYSTEM/linux/%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E5%9B%BE.png" width="50%" height="50%">
图1-1

unix系统的部分系统调用如图1-2

<img src="https://github.com/lzeus/mydata/raw/master/SYSTEM/linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.bmp" height="50%" width="80%">
图1-2

### 1.2. 文件IO相关的系统调用

- 打开文件

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

//根据文件路径与相关标识打开既有文件或新建文件，并返回文件描述符
int open(const char *pathname, int oflag,...);
//open的大文件支持版本，与调用open并使用O_LARGEFILE标识是等价的
int open64(const char *pathname, int oflag,...);
```
- 读文件

```c
#include <unistd.h>

ssize_t read(int fildes, void *buf, size_t nbyte);
```

- 写文件

```c
#include <unistd.h>

ssize_t write(int fildes, const void *buf, size_t nbyte);
```

- 关闭文件

```c
#include <unistd.h>
//关闭文件
int close(int fildes);
```


### 1.3. 使用IO系统调用完成文件复制

C语言中，调用系统函数与普通函数在使用上是没有区别的，下面将使用上述系统调用函数完成的文件复制操作。

- 生成测试文件

```bash
dd if=/dev/zero of=testfile.src count=1 bs=100M
```

- 使用系统调用完成文件复制的C程序

> SimpleCopy.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define MB 1

void unix_error(char *msg)
{	
	printf("%s: %s\n",msg,strerror(errno));
	exit(0);
}

int Open(char *pathname,int flag,mode_t mode)
{
	int fd = open64(pathname,flag,mode);
	
	if(fd < 0)
	{
		unix_error("打开文件错误");
	}
	return fd;
}

int openSourceFile(char  *sourceFile)
{
	return Open(sourceFile,O_RDONLY,0);
}

int openDestFile(char  *destFile)
{
	return Open(destFile,O_CREAT | O_TRUNC | O_RDWR ,0);
}

ssize_t Read(int fd,void *buf,size_t n)
{
	ssize_t num = read(fd,buf,n);	
	if(num < 0)
	{
		unix_error("读文件出错");
	}
	return num;
}

ssize_t Write(int fd,void *buf,size_t n)
{
	ssize_t num =  write(fd,buf,n);
	if(num < 0)
	{
		unix_error("写文件出错");
	}
	return num;
}

void Close(int fd)
{
	if(close(fd) < 0)
	{
		unix_error("关闭文件出错");
	}	
}

void closeFile(int fd)
{
	Close(fd);
}

void doCopy(int srcFd,int destFd)
{
	ssize_t num = -1;
	int n = 1024 * MB;
	//从堆中申请1024个字节作为BUFFER
	void *buf = Malloc(n);
	while((num = Read(srcFd,buf,n)) >  0)
	{
				
		Write(destFd,buf,(size_t)num);	
	}
}

int main(int argc,char  *argv[])
{
	if(argc != 3)
	{
		printf("用法\n SimpleCopy 源文件路径 目的文件路径\n");
		exit(0);
	}	
	
	int srcFd = openSourceFile(argv[1]);
	int destFd = openDestFile(argv[2]);

	doCopy(srcFd,destFd);

	closeFile(srcFd);
	closeFile(destFd);
}
```

- 编译执行

```bash
gcc ./SimpleCopy.c -o SimpleCopy && ./SimpleCopy testfile.src testfile.dest
```

### 1.4. JNI

- JDK的源码由大部分的C/C++加上少部分的汇编构成。

- 通过JNI体系，JAVA代码可以调用系统调用这样的本地函数。

> http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html

下面是遵循JNI规范，基于C语言的`printf`函数实现的经典程序HelloWorld。

#### 1.4.1 HelloWorldNative

###### 1.4.1.1. 本地方法申明

> `HelloWorldNative.java`

```java
public class HelloWorldNative{
		//本地方法say
		public static native void say();
}
```
###### 1.4.1.2. 生成的本地方法头文件

> `HelloWorldNative.h`

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorldNative */

#ifndef _Included_HelloWorldNative
#define _Included_HelloWorldNative
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorldNative
 * Method:    say
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloWorldNative_say
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif

```
###### 1.4.1.3. 本地方法实现

> `HelloWorldNative.c`

```c
#include "HelloWorldNative.h"
#include <stdio.h>
//方法名为全局符号
//命名约束为Java_类全路径名(_代替.)_方法名
JNIEXPORT void JNICALL Java_HelloWorldNative_say
  (JNIEnv *env, jclass cl)
{
		//from stdio.h
		printf("HelloWorld\n");
}
```

### 1.5. 小结

本章通过C语言实现的`SimpleCopy.c`，介绍了系统内核对于文件IO处理的基本支持，与其工作过程。

同时介绍了Java通过JNI是如何调用本地代码的。

下面章节，我们将通过OpenJDK(`openjdk-8-src-b132-03_mar_2014`)源码分析，了解Java是如何构建IO模块的。

> `http://www.java.net/download/openjdk/jdk8/promoted/b132/openjdk-8-src-b132-03_mar_2014.zip`


## 2. 面向文件流的Java IO

java将文件处理的过程抽象为流处理模型。

- 文件输入流`java.io.FileInputStream`用于处理文件读取。
- 文件输出流`java.io.FileOutInputStream`用于处理文件写入。


下文给出了`SimpleCopy.c`的Java版本`SimpleCopy.java`。

### 2.1. 面向流的文件复制

> SimpleCopy.java 

```java
import java.io.*;

public class SimpleCopy {

    public static final int MB = 1;
    public static void main(String args[]){
        if(args.length != 2){
            System.err.println("用法 \nSimpleCopy 源文件路径 目的文件路径");
            System.exit(-1);
        }

        String sourceFile = args[0];
        String destFile = args[1];
        //打开输入输出流
        InputStream inputStream = openSourceFile(sourceFile);
        OutputStream outputStream = openDestFile(destFile);
        //复制文件
        try{
            doCopy(inputStream,outputStream);
	     }catch (IOException e){
            System.err.println("将源文件 "+sourceFile+" 复制到 "+destFile+" 出错\n");
            e.printStackTrace();
        }finally{
            //关闭输入输出流
            closeFile(inputStream);
            closeFile(outputStream);
        }
    }
    
    public static InputStream openSourceFile(String sourceFile){
        try{
            return new FileInputStream(sourceFile);
        }catch (Exception e){
            System.err.println("源文件 "+sourceFile+" 打开出错\n");
            e.printStackTrace();
            System.exit(-1);
            return null;
        }
    }
    
    public static OutputStream openDestFile(String destFile){
        try{
            return new FileOutputStream(destFile);
        }catch (Exception e){
            System.err.println("目的文件 "+destFile+" 打开出错\n");
            e.printStackTrace();
            System.exit(-1);
            return null;
        }
    }
    
    public static void doCopy(InputStream inputStream,OutputStream outputStream) throws IOException{
       int n = -1; 
       byte[] buffer = new byte[1024 * MB];
       while(( n = inputStream.read(buffer,0,buffer.length)) > 0){
               outputStream.write(buffer,0,n);
       }
   }

    public static void closeFile(Closeable closeable){
        if(closeable != null){
            try{
                closeable.close();
            }catch (IOException e){
                //ignore ...
            }
        }
    }
}
```
#### 2.1.1. 打开输入输出流

###### 2.1.1.1. 打开文件输入流

1.调用链路如图2-1

<img src="https://github.com/lzeus/mydata/raw/master/PROGRAM/JAVA/io/%E6%90%9E%E6%87%82JavaIO-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6.png"/>图2-1

2.`java.io.FileInputStream`的构造函数调用了Java本地方法`open`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/share/classes/java/io/FileInputStream.java`

```java
public FileInputStream(File file) throws FileNotFoundException {
        String name = (file != null ? file.getPath() : null);
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(name);
        }
        if (name == null) {
            throw new NullPointerException();
        }
        if (file.isInvalid()) {
            throw new FileNotFoundException("Invalid file path");
        }
        fd = new FileDescriptor();
        fd.attach(this);
        //本地方法
        open(name);
    }
    
private native void open(String name) throws FileNotFoundException;
```

3.Java本地方法`open`对应的C方法实现为`Java_java_io_FileInputStream_open`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/share/native/java/io/FileInputStream.c`

```c
JNIEXPORT void JNICALL
Java_java_io_FileInputStream_open(JNIEnv *env, jobject this, jstring path) {
    fileOpen(env, this, path, fis_fd, O_RDONLY);
}
```

4.`Java_java_io_FileInputStream_open`会调用平台依赖实现的`handleOpen`方法。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/solaris/native/java/io/io_util_md.c`

```c
FD handleOpen(const char *path, int oflag, int mode) {
    //文件描述符
    FD fd;
    //打开文件
    RESTARTABLE(open64(path, oflag, mode), fd);
    if (fd != -1) {
        struct stat64 buf64;
        int result;
        RESTARTABLE(fstat64(fd, &buf64), result);
        if (result != -1) {
            if (S_ISDIR(buf64.st_mode)) {
                close(fd);
                errno = EISDIR;
                fd = -1;
            }
        } else {
            close(fd);
            fd = -1;
        }
    }
    return fd;
}
```

5.unix/linux平台依赖实现的`handleOpen`方法最终会调用系统函数`open64`方法。

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
//根据文件路径与相关标识打开既有文件或新建文件，并返回文件描述符
int open(const char *pathname, int oflag,...);
//open的大文件支持版本，与调用open并使用O_LARGEFILE标识是等价的
int open64(const char *pathname, int oflag,...);
```

###### 2.1.1.2. 打开文件输出流

`java.io.FileOutputStream `的构造函数调用了Java本地方法`open`，逻辑与`java.io.FileInputStream`构造函数一致。

#### 2.1.2. 复制文件

###### 2.1.2.1. 从源文件读取内容

1.调用链路如图2-2

<img src="https://github.com/lzeus/mydata/raw/master/PROGRAM/JAVA/io/%E6%90%9E%E6%87%82JavaIO-%E8%AF%BB%E6%96%87%E4%BB%B6.png">
图2-2

2.`java.io.FileInputStream`的`read`方法调用了Java本地方法`readBytes`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/share/classes/java/io/FileInputStream.java`

```java
public int read(byte b[]) throws IOException {
        return readBytes(b, 0, b.length);
}
```

3.Java本地方法`readBytes`对应的C方法实现为`Java_java_io_FileInputStream_readBytes`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/share/native/java/io/FileInputStream.c`

```c
JNIEXPORT jint JNICALL
Java_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,
        jbyteArray bytes, jint off, jint len) {
    return readBytes(env, this, bytes, off, len, fis_fd);
}
```

4.`Java_java_io_FileInputStream_readBytes`会调用平台依赖实现的`handleRead`方法。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/solaris/native/java/io/io_util_md.c`

```c
ssize_t
handleRead(FD fd, void *buf, jint len)
{
    ssize_t result;
    RESTARTABLE(read(fd, buf, len), result);
    return result;
}
```

5.unix/linux平台依赖实现的`handleRead`方法最终会调用系统函数`read`。

```c
#include <unistd.h>

ssize_t read(int fildes, void *buf, size_t nbyte);
```


###### 2.1.2.2. 将内容写入到目的文件

1.调用链路如图2-3

<img src="https://github.com/lzeus/mydata/raw/master/PROGRAM/JAVA/io/%E6%90%9E%E6%87%82JavaIO-%E5%86%99%E6%96%87%E4%BB%B6.png">
图2-3

2.`java.io.FileOutputStream`的`write`方法调用了Java本地方法`writeBytes`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/share/classes/java/io/FileOutputStream.java`

```java
public void write(byte b[], int off, int len) throws IOException {
        writeBytes(b, off, len, append);
}
```

3.Java本地方法`writeBytes`对应的平台依赖实现的C方法为`Java_java_io_FileInputStream_writeBytes`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/solaris/native/java/io/FileOutputStream_md.c`

```c
JNIEXPORT void JNICALL
Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,jobject this,
    jbyteArray bytes, jint off, jint len, jboolean append) {
    writeBytes(env, this, bytes, off, len, append, fos_fd);
}
```

4.unix/linux平台依赖实现的`Java_java_io_FileOutputStream_writeBytes`方法会调用平台依赖实现的`handleWrite`方法。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/solaris/native/java/io/io_util_md.c`

```c
ssize_t
handleWrite(FD fd, const void *buf, jint len)
{
    ssize_t result;
    RESTARTABLE(write(fd, buf, len), result);
    return result;
}
```

5.unix/linux平台依赖实现的`handleWrite`方法最终会调用系统函数`write`。

```c
#include <unistd.h>

ssize_t write(int fildes, const void *buf, size_t nbyte);
```

#### 2.1.3. 关闭输入输出流

###### 2.1.3.1. 关闭输入流

1.调用链路如图2-4

<img src="https://github.com/lzeus/mydata/raw/master/PROGRAM/JAVA/io/%E6%90%9E%E6%87%82JavaIO-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6.png">
图2-4

2.`java.io.FileOutputStream`的`close`方法调用了Java本地方法`close0`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/share/classes/java/io/FileInputStream.java`

```java
public void close() throws IOException {
        synchronized (closeLock) {
            if (closed) {
                return;
            }
            closed = true;
        }
        if (channel != null) {
           channel.close();
        }

        fd.closeAll(new Closeable() {
            public void close() throws IOException {
               close0();
           }
        });
}
```

3.Java本地方法`close0`对应的平台依赖实现的C方法为`Java_java_io_FileInputStream_close0`。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/solaris/native/java/io/FileInputStream_md.c`

```c
JNIEXPORT void JNICALL
Java_java_io_FileInputStream_close0(JNIEnv *env, jobject this) {
    fileClose(env, this, fis_fd);
}
```

4.unix/linux平台依赖实现的`Java_java_io_FileInputStream_close0`方法会调用平台依赖实现的`fileClose`方法。

> `openjdk-8-src-b132-03_mar_2014/jdk/src/solaris/native/java/io/io_util_md.c`

```c
void
fileClose(JNIEnv *env, jobject this, jfieldID fid)
{
    FD fd = GET_FD(this, fid);
    if (fd == -1) {
        return;
    }

    /* Set the fd to -1 before closing it so that the timing window
     * of other threads using the wrong fd (closed but recycled fd,
     * that gets re-opened with some other filename) is reduced.
     * Practically the chance of its occurance is low, however, we are
     * taking extra precaution over here.
     */
    SET_FD(this, -1, fid);

    /*
     * Don't close file descriptors 0, 1, or 2. If we close these stream
     * then a subsequent file open or socket will use them. Instead we
     * just redirect these file descriptors to /dev/null.
     */
    if (fd >= STDIN_FILENO && fd <= STDERR_FILENO) {
        int devnull = open("/dev/null", O_WRONLY);
        if (devnull < 0) {
            SET_FD(this, fd, fid); // restore fd
            JNU_ThrowIOExceptionWithLastError(env, "open /dev/null failed");
        } else {
            dup2(devnull, fd);
            close(devnull);
        }
    } else if (close(fd) == -1) {
        JNU_ThrowIOExceptionWithLastError(env, "close failed");
    }
}
```

5.unix/linux平台依赖实现的`fileClose`方法最终会调用系统函数`close`。

```c
#include <unistd.h>

int close(int fildes);
```

###### 2.1.3.2. 关闭输出流

文件输出流的关闭逻辑与输入流大致相同。

### 2.2 小节

Java IO的流模型大致如此。

JDK1.4之后，新增了针对IO处理的高级特性，这些特性以Channel为抽象入口，本系列下篇文章将会介绍这方面的内容。
